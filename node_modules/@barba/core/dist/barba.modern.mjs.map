{"version":3,"file":"barba.modern.mjs","sources":["../src/modules/Logger.ts","../src/defs/hooks.ts","../../../node_modules/path-to-regexp/dist.es2015/index.js","../src/schemas/attribute.ts","../src/utils/dom.ts","../src/utils/history.ts","../src/utils/helpers.ts","../src/utils/url.ts","../src/utils/request.ts","../src/utils/run-async.ts","../../../node_modules/is-promise/index.mjs","../src/hooks.ts","../src/modules/Ignore.ts","../src/modules/Cache.ts","../src/modules/Headers.ts","../src/modules/Prevent.ts","../src/modules/Error.ts","../src/modules/Store.ts","../src/modules/Transitions.ts","../src/modules/Views.ts","../src/polyfills/index.ts","../src/schemas/page.ts","../src/core.ts"],"sourcesContent":["/**\n * @barba/core/modules/Logger\n * <br><br>\n * ## Logger.\n *\n * - Display informations via the console\n *\n * @module core/modules/Logger\n * @preferred\n */\n\n/***/\n\n/**\n * Log levels, all lower level messages are printed\n *\n * 0. mute\n * 1. error = `console.error()`\n * 2. warning= `console.warn()`\n * 3. info = `console.info()`\n * 4. debug = `console.log()`\n */\nexport enum LogLevels {\n  off = 0,\n  error = 1,\n  warning = 2,\n  info = 3,\n  debug = 4,\n}\n\n/**\n * Global log level\n */\nlet _level: number = LogLevels.off;\n\nexport class Logger {\n  /**\n   * Get global log level.\n   */\n  public static getLevel(): number {\n    return _level;\n  }\n\n  /**\n   * Set global log level.\n   */\n  public static setLevel(name: keyof typeof LogLevels): number {\n    _level = LogLevels[name];\n\n    return _level;\n  }\n\n  /**\n   * Log \"prefix\".\n   */\n  private _source: string;\n\n  /**\n   * Creates an instance of Logger.\n   */\n  constructor(source: string) {\n    this._source = source;\n  }\n\n  /**\n   * Permanent, unremovable log.\n   */\n  // public print(...objects: any[]): void {\n  //   this._log(console.info, LogLevels.off, objects);\n  // }\n\n  /**\n   * Error log.\n   */\n  public error(...objects: any[]): void {\n    this._log(console.error, LogLevels.error, objects);\n  }\n\n  /**\n   * Warn log.\n   */\n  public warn(...objects: any[]): void {\n    this._log(console.warn, LogLevels.warning, objects);\n  }\n\n  /**\n   * Info log.\n   */\n  public info(...objects: any[]): void {\n    this._log(console.info, LogLevels.info, objects);\n  }\n\n  /**\n   * Debug log.\n   */\n  public debug(...objects: any[]): void {\n    this._log(console.log, LogLevels.debug, objects);\n  }\n\n  /**\n   * Internal logger.\n   */\n  private _log(fn: () => void, level: number, objects: any[]): void {\n    if (level <= Logger.getLevel()) {\n      fn.apply(console, ([`[${this._source}] `].concat(objects) as unknown) as [\n\n      ]);\n    }\n  }\n}\n","/**\n * @module typings/core\n */\nimport { ITransitionData, ITransitionPage, IViewData } from './index';\n\nexport type HooksBarba =\n  | 'ready'\n  | 'page'\n  | 'reset'\n  | 'currentAdded'\n  | 'currentRemoved'\n  | 'nextAdded'\n  | 'nextRemoved';\n\nexport type HooksOnce = 'beforeOnce' | 'once' | 'afterOnce';\n\nexport type HooksPage =\n  | 'before'\n  | 'beforeLeave'\n  | 'leave'\n  | 'afterLeave'\n  | 'beforeEnter'\n  | 'enter'\n  | 'afterEnter'\n  | 'after';\n\nexport type HooksBefore = 'beforeOnce' | 'beforeLeave' | 'beforeEnter';\nexport type HooksAfter = 'afterOnce' | 'afterLeave' | 'afterEnter';\n\nexport type HooksTransition = HooksOnce | HooksPage;\nexport type HooksView = HooksBefore | HooksAfter;\nexport type HooksAll = HooksBarba | HooksTransition;\n\n// Allow optional \"dynamically created\" hooks\nexport type HooksTransitionMap = { [key in HooksTransition]?: any };\n\nexport type HookFunction = (\n  data?: ITransitionData | IViewData,\n  t?: ITransitionPage\n) => Promise<void> | void;\n\nexport class HookMethods {\n  public before: (fn: HookFunction, ctx?: any) => void;\n  public beforeLeave: (fn: HookFunction, ctx?: any) => void;\n  public leave: (fn: HookFunction, ctx?: any) => void;\n  public afterLeave: (fn: HookFunction, ctx?: any) => void;\n  public beforeEnter: (fn: HookFunction, ctx?: any) => void;\n  public enter: (fn: HookFunction, ctx?: any) => void;\n  public afterEnter: (fn: HookFunction, ctx?: any) => void;\n  public after: (fn: HookFunction, ctx?: any) => void;\n}\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","/**\n * @barba/core/schemas\n * <br><br>\n * ## Schemas description.\n *\n * @module core/schemas\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { ISchemaAttribute } from '../defs';\n\n/**\n * See [[ISchemaAttribute]]\n */\nexport const schemaAttribute: ISchemaAttribute = {\n  container: 'container',\n  history: 'history',\n  namespace: 'namespace',\n  prefix: 'data-barba',\n  prevent: 'prevent',\n  wrapper: 'wrapper',\n};\n","/**\n * @barba/core/utils/dom\n * <br><br>\n * ## Dom utils\n *\n * - Access DOM contents\n * - DOM vs string conversions\n *\n * @module core/utils/dom\n * @preferred\n */\n\n/***/\n\nimport path from 'path';\n\n// Definitions\nimport { IDomSibling, ISchemaAttribute, Link, Scope, Wrapper } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\nexport class Dom {\n  private _attr: ISchemaAttribute = schemaAttribute;\n  private _parser: DOMParser;\n  private _sibling: IDomSibling = {\n    after: null,\n    before: null,\n    parent: null\n  };\n\n  /**\n   * Convert HTMLDocument to string.\n   */\n  public toString(el: HTMLElement): string {\n    return el.outerHTML;\n  }\n\n  /**\n   * Parse HTML string to HTMLDocument.\n   */\n  // see https://github.com/barbajs/barba/issues/362\n  // Seems that using DOMParser.parseFromString causes this issue.\n  public toDocument(htmlString: string): HTMLDocument {\n    /* istanbul ignore else */\n    if (!this._parser) {\n      this._parser = new DOMParser();\n    }\n    return this._parser.parseFromString(htmlString, 'text/html');\n  }\n\n  /**\n   * Parse HTML string to DIVElement.\n   *\n   * DOMParser.parseFromString fails with img[srcset] on iOS.\n   * see https://github.com/barbajs/barba/issues/362\n   */\n  public toElement(htmlString: string): HTMLDivElement {\n    const div = document.createElement('div');\n\n    div.innerHTML = htmlString;\n    return div;\n  }\n\n  /**\n   * Get HTML content.\n   */\n  public getHtml(doc: HTMLDocument = document): string {\n    return this.toString(doc.documentElement);\n  }\n\n  /**\n   * Get full document content.\n   */\n  // getDocument(el = document.documentElement) {\n  //   return this.toStr(el);\n  // },\n\n  /**\n   * Get `[data-barba=\"wrapper\"]`.\n   */\n  public getWrapper(scope: Scope = document): Wrapper {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.wrapper}\"]`\n    );\n  }\n\n  /**\n   * Get `[data-barba=\"container\"]`.\n   */\n  public getContainer(scope: Scope = document): HTMLElement | null {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.container}\"]`\n    );\n  }\n\n  /**\n   * Remove container and store next sibling (if applicable).\n   */\n  public removeContainer(container: HTMLElement) {\n    if (document.body.contains(container)) {\n      this._updateSibling(container);\n      container.parentNode.removeChild(container);\n    }\n  }\n\n  /**\n   * Add container near previous container\n   */\n  public addContainer(container: HTMLElement, wrapper: HTMLElement) {\n    const siblingBefore = this.getContainer() || this._sibling.before;\n\n    if (siblingBefore) {\n      this._insertAfter(container, siblingBefore);\n    } else if (this._sibling.after) {\n      this._sibling.after.parentNode.insertBefore(container, this._sibling.after);\n    } else if (this._sibling.parent) {\n      this._sibling.parent.appendChild(container);\n    } else {\n      wrapper.appendChild(container);\n    }\n  }\n\n  /**\n   * Get current dom sibling\n   */\n  public getSibling(): IDomSibling {\n    return this._sibling;\n  }\n\n  /**\n   * Get `[data-barba-namespace]`.\n   */\n  public getNamespace(scope: Scope = document): string | null {\n    const ns = scope.querySelector(\n      `[${this._attr.prefix}-${this._attr.namespace}]`\n    );\n\n    return ns\n      ? ns.getAttribute(`${this._attr.prefix}-${this._attr.namespace}`)\n      : null;\n  }\n\n  /**\n   * Get URL from `href` value.\n   */\n  public getHref(el: Link): string | null {\n    // HTML tagName is UPPERCASE, xhtml tagName keeps existing case.\n    if (el.tagName && el.tagName.toLowerCase() === 'a') {\n      // HTMLAnchorElement, full URL available\n      if (typeof el.href === 'string') {\n        return el.href;\n      }\n\n      // Probably a SVGAElement…\n      const href = el.getAttribute('href') || el.getAttribute('xlink:href');\n\n      /* istanbul ignore else */\n      if (href) {\n        // When link comes from SVG, `href` returns an object, not a string.\n        const attr: string =\n          ((href as unknown) as SVGAnimatedString).baseVal || href;\n\n        return this.resolveUrl(attr);\n      }\n    }\n    return null;\n  }\n\n  // Copyright 2014 Simon Lydell\n  // X11 (“MIT”) Licensed. (See LICENSE\n  // https://github.com/lydell/resolve-url/blob/master/resolve-url.js\n  /* istanbul ignore next */\n  public resolveUrl(...urls: string[]) {\n    const numUrls = urls.length;\n\n    if (numUrls === 0) {\n      throw new Error('resolveUrl requires at least one argument; got none.');\n    }\n\n    const base = document.createElement('base');\n    base.href = arguments[0];\n\n    if (numUrls === 1) {\n      return base.href;\n    }\n\n    const head = document.getElementsByTagName('head')[0];\n    head.insertBefore(base, head.firstChild);\n\n    const a = document.createElement('a');\n    let resolved;\n\n    for (let index = 1; index < numUrls; index++) {\n      a.href = arguments[index];\n      resolved = a.href;\n      base.href = resolved;\n    }\n\n    head.removeChild(base);\n\n    return resolved;\n  }\n\n  /**\n   * Insert node after another node.\n   */\n  private _insertAfter(newNode: Node, referenceNode: Node) {\n    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n  }\n\n  /**\n   * Update current dom sibling regarding container\n   */\n  private _updateSibling(container: HTMLElement): IDomSibling {\n    this._sibling = {\n      after: container.nextElementSibling,\n      before: container.previousElementSibling,\n      parent: container.parentElement\n    };\n\n    return this._sibling;\n  }\n}\n\nconst dom = new Dom();\n\nexport { dom };\n","import { HistoryAction, LinkEvent, Trigger } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\n/**\n * @barba/core/utils/history\n * <br><br>\n * ## History manager.\n *\n * - Keep track of the navigation history\n *\n * @module core/utils/history\n * @preferred\n */\n\n/**\n * State item.\n *\n * @property from\n * @property index\n */\ninterface IHistoryItem {\n  /** origin */\n  from: string;\n  /** index */\n  index: number;\n  /** states */\n  states: IStateItem[];\n}\n\n/***/\ninterface ICoords {\n  x: number;\n  y: number;\n}\n\n/**\n * History item.\n *\n * @property namespace\n * @property scroll\n * @property URL\n */\ninterface IStateItem {\n  /** data */\n  data: object;\n  /** namespace */\n  ns: string | undefined;\n  /** Scroll position */\n  scroll: ICoords;\n  /** URL */\n  url: string;\n}\n\nexport class History {\n  private _session: string;\n  private _states: IStateItem[] = [];\n  private _pointer = -1;\n\n  /**\n   * Init with first state.\n   */\n  public init(url: string, ns: string): void {\n    this._session = 'barba';\n\n    const state: IStateItem = {\n      data: {},\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._pointer = 0;\n    this._states.push(state);\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index: this._pointer,\n      states: [...this._states],\n    };\n\n    window.history && window.history.replaceState(item, '', url);\n  }\n\n  public change(\n    url: string,\n    trigger: Trigger,\n    e?: LinkEvent | PopStateEvent\n  ): Trigger {\n    if (e && (e as PopStateEvent).state) {\n      // If popstate, move to existing state\n      // and get back/forward direction.\n      const { state }: { state: IHistoryItem } = e as PopStateEvent;\n      const { index } = state;\n      const diff = this._pointer - index;\n\n      trigger = this._getDirection(diff);\n\n      // Work with previous states\n      this.replace(state.states);\n      this._pointer = index;\n    } else {\n      // Add new state\n      this.add(url, trigger);\n    }\n\n    return trigger;\n  }\n\n  /**\n   * Add a new state.\n   */\n  public add(url: string, trigger: Trigger, action?: HistoryAction, data?: object): void {\n    // If no state, it will be updated later.\n    const ns = 'tmp';\n    const method = action ?? this._getAction(trigger);\n    const state: IStateItem = {\n      data: data ?? {},\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    switch (method) {\n      case 'push':\n        this._pointer = this.size;\n        this._states.push(state);\n        break;\n      case 'replace':\n        this.set(this._pointer, state);\n        break;\n      /* istanbul ignore next */\n      default:\n    }\n\n    const item: IHistoryItem = {\n      from: this._session,\n      index: this._pointer,\n      states: [...this._states],\n    };\n\n    switch (method) {\n      case 'push':\n        window.history && window.history.pushState(item, '', url);\n        break;\n      case 'replace':\n        window.history && window.history.replaceState(item, '', url);\n        break;\n      /* istanbul ignore next */\n      default:\n    }\n  }\n\n  /**\n   * Store custom user data per state.\n   */\n   public store(data: object, i?: number): void {\n     const index = i || this._pointer;\n     const state = this.get(index);\n\n     // merge data (allow data overwrite)\n     state.data = {\n       ...state.data,\n       ...data\n     };\n\n     // update states\n     this.set(index, state);\n\n     const item: IHistoryItem = {\n       from: this._session,\n       index: this._pointer,\n       states: [...this._states],\n     };\n\n     // update browser history\n     window.history.replaceState(item, '');\n   }\n\n  /**\n   * Update state.\n   */\n  public update(data: any, i?: number): void {\n    const index = i || this._pointer;\n    const existing = this.get(index);\n    const state: IStateItem = {\n      ...existing,\n      ...data,\n    };\n\n    this.set(index, state);\n  }\n\n  /**\n   * Remove last state.\n   */\n  public remove(i?: number): void {\n    if (i) {\n      this._states.splice(i, 1);\n    } else {\n      this._states.pop();\n    }\n\n    this._pointer--;\n  }\n\n  /**\n   * Delete all states.\n   */\n  public clear(): void {\n    this._states = [];\n    this._pointer = -1;\n  }\n\n  /**\n   * Replace all states.\n   */\n  public replace(newStates: IStateItem[]): void {\n    this._states = newStates;\n  }\n\n  /**\n   * Get state by index.\n   */\n  public get(index: number): IStateItem {\n    return this._states[index];\n  }\n\n  /**\n   * Set state by index.\n   */\n  public set(i: number, state: IStateItem) {\n    return (this._states[i] = state);\n  }\n\n  /**\n   * Get the current state.\n   */\n  get current(): IStateItem {\n    return this._states[this._pointer];\n  }\n\n  /**\n   * Get the previous state.\n   */\n  get previous(): IStateItem | null {\n    return this._pointer < 1 ? null : this._states[this._pointer - 1];\n  }\n\n  /**\n   * Get the state size.\n   */\n  get size(): number {\n    return this._states.length;\n  }\n\n  /**\n   * Get the history action: push vs replace\n   */\n  private _getAction(trigger: Trigger): HistoryAction {\n    let action: HistoryAction = 'push';\n\n    // Manage `data-barba-history` attribute\n    // to get the right action (push vs replace).\n    const el = trigger as HTMLAnchorElement;\n    const attr = `${schemaAttribute.prefix}-${schemaAttribute.history}`;\n\n    if (el.hasAttribute && el.hasAttribute(attr)) {\n      action = el.getAttribute(attr) as HistoryAction;\n    }\n\n    return action;\n  }\n\n  /**\n   * Get the direction of popstate change\n   */\n  private _getDirection(diff: number): Trigger {\n    // Check if \"session switch\"\n    if (Math.abs(diff) > 1) {\n      // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\n      return diff > 0 ? 'forward' : 'back';\n    } else {\n      if (diff === 0) {\n        return 'popstate';\n      } else {\n        // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\n        return diff > 0 ? 'back' : 'forward';\n      }\n    }\n  }\n}\n\nconst history = new History();\n\nexport { history };\n","/**\n * @barba/core/utils/helpers\n * <br><br>\n * ## Helpers\n *\n * - Update next page data\n *\n * @module core/utils/helpers\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport { pathToRegexp as ptr } from 'path-to-regexp';\n// Definitions\nimport { IResponse, ITransitionData } from '../defs';\n// Utils\nimport { dom } from './dom';\nimport { history } from './history';\n\n/**\n * Update `data.next`, the title and the history\n */\nexport const update = async (\n  page: Promise<IResponse | void>,\n  data: ITransitionData\n): Promise<void> => {\n  // If not already updated\n  if (!data.next.html) {\n    const response = await page;\n    const { next } = data;\n\n    if (response) {\n      // see: https://github.com/barbajs/barba/issues/362\n      // const nextDocument = dom.toDocument(html);\n      const nextDocument = dom.toElement(response.html);\n\n      next.namespace = dom.getNamespace(nextDocument);\n      next.container = dom.getContainer(nextDocument);\n      // see https://github.com/barbajs/barba/issues/362\n      // next.html = dom.getHtml(nextDocument);\n      // next.html = nextDocument.innerHTML;\n      next.url = response.url;\n      next.html = response.html;\n\n      // Update history namespace (not available when initially set)\n      history.update({ ns: next.namespace });\n\n      // Update title.\n      const { title } = dom.toDocument(response.html);\n\n      document.title = title;\n    }\n  }\n};\n\n/**\n * Next tick\n */\nexport const nextTick = () =>\n  new Promise(resolve => {\n    window.requestAnimationFrame(resolve);\n    // DEV: same result?\n    // setTimeout(resolve, 0);\n  });\n\n/**\n * Turn a route string such as `/user/:name` into a regular expression.\n *\n * Used for:\n *\n * - routes to ignore\n * - route transition resolution\n *\n * @see https://www.npmjs.com/package/path-to-regexp\n */\nconst pathToRegexp = ptr;\n\nexport { pathToRegexp };\n","/**\n * @barba/core/utils/url\n * <br><br>\n * ## URL utils.\n *\n * - Collect and structure informations from URLs\n *\n * @module core/utils/url\n */\n\n/***/\n\n// Definitions\nimport { IGenericObject, IUrlBase } from '../defs';\n\n/**\n * Get location href.\n */\nexport const getHref = () => window.location.href;\n\n/**\n * Get absolute href from URL.\n */\nexport const getAbsoluteHref = (url: string, base: string = document.baseURI): string => new URL(url, base).href;\n\n/**\n * Get location origin.\n */\nexport const getOrigin = () => window.location.origin;\n\n/**\n * Get port based on URL or location.\n */\nexport const getPort = (url: string = window.location.href) => parse(url).port;\n\n/**\n * Get path from URL.\n */\nexport const getPath = (url: string = window.location.href) => parse(url).path;\n\n/**\n * Get query object from URL.\n */\nexport const getQuery = (url: string, stringify: boolean = false): IGenericObject|string => {\n  return stringify ? JSON.stringify(parse(url).query) : parse(url).query;\n};\n\n/**\n * Get hash from URL.\n */\nexport const getHash = (url: string): string => parse(url).hash;\n\n/**\n * Parse URL for path, query and hash and more.\n */\nexport const parse = (url: string): IUrlBase => {\n  // Port\n  let port;\n  const matches = url.match(/:\\d+/);\n\n  if (matches === null) {\n    if (/^http/.test(url)) {\n      port = 80;\n    }\n\n    if (/^https/.test(url)) {\n      port = 443;\n    }\n  } else {\n    const portString = matches[0].substring(1);\n\n    port = parseInt(portString, 10);\n  }\n\n  // Path\n  let path = url.replace(getOrigin(), '');\n  let hash;\n  let query = {};\n\n  // Hash\n  const hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex + 1);\n    path = path.slice(0, hashIndex);\n  }\n\n  // Query\n  const queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = parseQuery(path.slice(queryIndex + 1));\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    hash,\n    path,\n    port,\n    query,\n  };\n};\n\n/**\n * Parse a query string to object.\n */\nexport const parseQuery = (str: string) =>\n  str.split('&').reduce((acc: IGenericObject, el: string) => {\n    const [key, value] = el.split('=');\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n\n/**\n * Clean URL, remove \"hash\" and/or \"trailing slash\".\n */\nexport const clean = (url: string = window.location.href) =>\n  url.replace(/(\\/#.*|\\/|#.*)$/, '');\n","/**\n * @barba/core/utils/request\n * <br><br>\n * ## Fetch pages for transitions.\n *\n * - Includes timeout\n * - Uses Fetch API\n * - Handles errors\n *\n * @module core/utils/request\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { Cache } from '@barba/core/src/modules/Cache';\nimport { Headers } from '@barba/core/src/modules/Headers';\nimport { IResponse, RequestError } from '../defs';\nimport { parse } from './url';\n\n/**\n * Init a page request.\n * Fetch the page and returns a promise with the text content.\n */\nfunction request(\n  url: string,\n  ttl: number = 2e3,\n  requestError: RequestError,\n  cache: Cache,\n  headers: Headers\n): Promise<IResponse> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          /* istanbul ignore next: bypass jest since xhr-mock doesn't support custom xhr.responseURL */\n          const responseURL = xhr.responseURL !== '' && xhr.responseURL !== url ? xhr.responseURL : url;\n\n          resolve({\n            html: xhr.responseText,\n            url: {\n              href: responseURL,\n              ...parse(responseURL)\n            },\n          });\n\n          cache.update(url, {\n            status: 'fulfilled',\n            target: responseURL\n          });\n        } else if (xhr.status) {\n          // HTTP code is not 200, reject with response.\n          const response = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n          };\n\n          requestError(url, response);\n          reject(response);\n\n          cache.update(url, { status: 'rejected' });\n        }\n      }\n    };\n\n    xhr.ontimeout = () => {\n      const error = new Error(`Timeout error [${ttl}]`);\n      requestError(url, error);\n      reject(error);\n      cache.update(url, { status: 'rejected' });\n    };\n\n    xhr.onerror = () => {\n      const error = new Error(`Fetch error`);\n      requestError(url, error);\n      reject(error);\n      cache.update(url, { status: 'rejected' });\n    };\n\n    xhr.open('GET', url);\n    xhr.timeout = ttl;\n    xhr.setRequestHeader(\n      'Accept',\n      'text/html,application/xhtml+xml,application/xml'\n    );\n    xhr.setRequestHeader('x-barba', 'yes');\n\n    headers.all().forEach((value, key) => {\n      xhr.setRequestHeader(key, value);\n    });\n\n    xhr.send();\n  });\n}\n\nexport { request };\n","import isPromise from 'is-promise';\n\n// https://github.com/SBoudrias/run-async\n/* istanbul ignore next */\nexport function runAsync(\n  func: (...args: any[]) => void | Promise<any>,\n  ctx: any = {}\n): (...args: any[]) => Promise<any> {\n  return (...args: any[]) => {\n    let async = false;\n\n    const promise = new Promise((resolve, reject) => {\n      // Add async to context\n      ctx.async = () => {\n        async = true;\n\n        return (err: any, value: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        };\n      };\n\n      const answer = func.apply(ctx, args as []);\n\n      if (!async) {\n        if (isPromise(answer)) {\n          (answer as Promise<any>).then(resolve, reject);\n        } else {\n          resolve(answer);\n        }\n      }\n    });\n\n    return promise;\n  };\n}\n","export default function isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n","/**\n * @barba/core/modules/hooks\n * <br><br>\n * ## Hooks manager.\n *\n * - Register and trigger hooks\n *\n * Hooks can be easily registered:\n *\n * ```js\n * hooks.leave(callback, context);\n * ```\n *\n * @module core/modules/hooks\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HookFunction, HookMethods, HooksAll } from './defs';\n// Modules\nimport { Logger } from './modules/Logger';\n// Utils\nimport { runAsync } from './utils';\n// Types\ninterface IHookInfos {\n  ctx: any;\n  fn: HookFunction;\n}\n\nexport class Hooks extends HookMethods {\n  /**\n   * Allow the use of `hooks[name](cb, ctx)`.\n   */\n  [key: string]: any;\n  // [key in HooksAll]?: any;\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All available hooks.\n   *\n   * See [[HooksAll]]\n   */\n  // TODO: get hooks from defs (DRY)?\n  public all: HooksAll[] = [\n    'ready',\n    'page',\n    'reset',\n    'currentAdded',\n    'currentRemoved',\n    'nextAdded',\n    'nextRemoved',\n    'beforeOnce',\n    'once',\n    'afterOnce',\n    'before',\n    'beforeLeave',\n    'leave',\n    'afterLeave',\n    'beforeEnter',\n    'enter',\n    'afterEnter',\n    'after',\n  ];\n  /**\n   * Registered hooks.\n   *\n   * - Unique hook name\n   * - Associated data set(s) (callback + context)\n   */\n  public registered: Map<HooksAll, Set<IHookInfos>> = new Map();\n\n  constructor() {\n    super();\n    this.init();\n  }\n\n  public init() {\n    this.registered.clear();\n    this.all.forEach(hook => {\n      if (!this[hook]) {\n        this[hook] = (fn: HookFunction, ctx?: any) => {\n          if (!this.registered.has(hook)) {\n            this.registered.set(hook, new Set());\n          }\n          const set = this.registered.get(hook);\n\n          set.add({\n            ctx: ctx || {},\n            fn,\n          });\n        };\n      }\n    });\n  }\n\n  /**\n   * Do hook.\n   *\n   * Trigger registered hooks.\n   */\n  public do(name: HooksAll, ...args: any): Promise<any> {\n    if (this.registered.has(name)) {\n      // Let's start a chain of promises\n      let chain = Promise.resolve();\n\n      this.registered.get(name).forEach(hook => {\n        // Chain async hooks promisified\n        chain = chain.then(() => runAsync(hook.fn, hook.ctx)(...args));\n      });\n\n      return chain.catch(error => {\n        this.logger.debug(`Hook error [${name}]`);\n        this.logger.error(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  public clear(): void {\n    this.all.forEach(hook => {\n      delete this[hook];\n    });\n\n    this.init();\n  }\n\n  /**\n   * Help, print available and registered hooks.\n   */\n  public help(): void {\n    this.logger.info(`Available hooks: ${this.all.join(',')}`);\n    const registered: string[] = [];\n    this.registered.forEach((_value: any, key: string) => registered.push(key));\n    this.logger.info(`Registered hooks: ${registered.join(',')}`);\n  }\n}\n\nconst hooks = new Hooks();\n\nexport { hooks };\n","/**\n * @barba/core/modules/ignore\n * <br><br>\n * ## Manage ignore options.\n *\n * - cache\n * - prefetch\n *\n * @module core/modules/ignore\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption } from '../defs';\n// Utils\nimport { pathToRegexp } from '../utils/helpers';\nimport { parse } from '../utils/url';\n\nexport class Ignore {\n  private _ignoreAll: boolean;\n  private _ignoreRegexes: RegExp[] = [];\n\n  constructor(ignore: IgnoreOption) {\n    if (typeof ignore === 'boolean') {\n      this._ignoreAll = ignore;\n    } else {\n      const paths = Array.isArray(ignore) ? ignore : [ignore];\n\n      this._ignoreRegexes = paths.map(p => pathToRegexp(p));\n    }\n  }\n\n  public checkHref(href: string): boolean {\n    if (typeof this._ignoreAll === 'boolean') {\n      return this._ignoreAll;\n    }\n\n    const { path } = parse(href);\n\n    return this._ignoreRegexes.some(regex => regex.exec(path) !== null);\n  }\n}\n","/**\n * @barba/core/modules/cache\n * <br><br>\n * ## Cache for storing URL / HTML.\n *\n * @module core/modules/cache\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { CacheAction, CacheRequest, CacheStatus, CacheTarget, ICacheData, IgnoreOption } from '../defs';\n// Modules\nimport { Ignore } from './Ignore';\n\nexport class Cache extends Ignore {\n  private _state: Map<string, ICacheData> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n  }\n\n  /**\n   * Set value to cache\n   */\n  public set(\n    href: string,\n    request: CacheRequest,\n    action: CacheAction,\n    status: CacheStatus,\n    target?: CacheTarget,\n  ): ICacheData {\n    this._state.set(href, {\n      action,\n      request,\n      status,\n      target: target ?? href,\n    });\n\n    return {\n      action,\n      request,\n      status,\n      target,\n    };\n  }\n\n  /**\n   * Get data from cache\n   */\n  public get(href: string): ICacheData {\n    return this._state.get(href);\n  }\n\n  /**\n   * Get request from cache\n   */\n  public getRequest(href: string): CacheRequest {\n    return this._state.get(href).request;\n  }\n\n  /**\n   * Get action from cache\n   */\n  public getAction(href: string): CacheAction {\n    return this._state.get(href).action;\n  }\n\n  /**\n   * Get status from cache\n   */\n  public getStatus(href: string): CacheStatus {\n    return this._state.get(href).status;\n  }\n\n  /**\n   * Get target from cache\n   */\n  public getTarget(href: string): CacheTarget {\n    return this._state.get(href).target;\n  }\n\n  /**\n   * Check if value exists into cache\n   */\n  public has(href: string): boolean {\n    /* istanbul ignore else */\n    if (this.checkHref(href)) {\n      return false;\n    }\n    return this._state.has(href);\n  }\n\n  /**\n   * Delete value from cache\n   */\n  public delete(href: string): boolean {\n    return this._state.delete(href);\n  }\n\n  /**\n   * Update cache value\n   */\n  public update(href: string, data: ICacheData): ICacheData {\n    const state = {\n      ...this._state.get(href),\n      ...data,\n    };\n    this._state.set(href, state);\n\n    return state;\n  }\n}\n","/**\n * @barba/core/modules/headers\n * <br><br>\n * ## Manage request Headers.\n *\n * @module core/modules/headers\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HeaderList, IHeaderData } from '../defs';\n\nexport class Headers {\n  private _list: HeaderList = new Map();\n\n  /**\n   * Set a new header\n   */\n  public set(name: string, value: string): IHeaderData {\n    this._list.set(name, value);\n\n    return {\n      name: value\n    };\n  }\n\n  /**\n   * Get a specific header\n   */\n  public get(name: string): string {\n    return this._list.get(name);\n  }\n\n  /**\n   * Get all headers\n   */\n  public all(): HeaderList {\n    return this._list;\n  }\n\n  /**\n   * Check if header exists\n   */\n  public has(name: string): boolean {\n    return this._list.has(name);\n  }\n\n  /**\n   * Delete a header\n   */\n  public delete(name: string): boolean {\n    return this._list.delete(name);\n  }\n\n  /**\n   * Clear all headers\n   */\n  public clear(): void {\n    return this._list.clear();\n  }\n}\n","/**\n * @barba/core/modules/prevent\n * <br><br>\n * ## Prevent checks.\n *\n * - Gathers all the tests that allow Barba to work and play transitions\n *\n * @module core/modules/prevent\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption, Link, PreventCheck } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n// Utils\nimport { url } from '../utils';\n// Modules\nimport { Ignore } from './Ignore';\n\n/**\n * Make sure the browser supports `history.pushState`.\n */\nconst pushState: PreventCheck = () => !window.history.pushState;\n\n/**\n * Make sure there is an `el` and `href`.\n */\nconst exists: PreventCheck = ({ el, href }) => !el || !href;\n\n/**\n * If the user is pressing ctrl + click, the browser will open a new tab.\n */\nconst newTab: PreventCheck = ({ event }) =>\n  (event as KeyboardEvent).which > 1 ||\n  (event as KeyboardEvent).metaKey ||\n  (event as KeyboardEvent).ctrlKey ||\n  (event as KeyboardEvent).shiftKey ||\n  (event as KeyboardEvent).altKey;\n\n/**\n * If the link has `_blank` target.\n */\nconst blank: PreventCheck = ({ el }) =>\n  el.hasAttribute('target') && (el as Link).target === '_blank';\n\n/**\n * If the domain is the same (in order to avoid pushState cross origin security problem).\n * Note: SVGAElement do not have `protocol` neither `hostname` properties.\n */\nconst corsDomain: PreventCheck = ({ el }) =>\n  ((el as HTMLAnchorElement).protocol !== undefined &&\n    window.location.protocol !== (el as HTMLAnchorElement).protocol) ||\n  ((el as HTMLAnchorElement).hostname !== undefined &&\n    window.location.hostname !== (el as HTMLAnchorElement).hostname);\n\n/**\n * If the port is the same.\n * Note: SVGAElement do not have `port` property.\n */\nconst corsPort: PreventCheck = ({ el }) =>\n  (el as HTMLAnchorElement).port !== undefined &&\n  url.getPort() !== url.getPort((el as HTMLAnchorElement).href);\n\n/**\n * If the link has download attribute.\n */\nconst download: PreventCheck = ({ el }) =>\n  el.getAttribute && typeof el.getAttribute('download') === 'string';\n\n/**\n * If the links contains [data-barba-prevent] or [data-barba-prevent=\"self\"].\n */\nconst preventSelf: PreventCheck = ({ el }) =>\n  el.hasAttribute(`${schemaAttribute.prefix}-${schemaAttribute.prevent}`);\n\n/**\n * If some link ancestor contains [data-barba-prevent=\"all\"].\n */\nconst preventAll: PreventCheck = ({ el }) =>\n  Boolean(\n    el.closest(`[${schemaAttribute.prefix}-${schemaAttribute.prevent}=\"all\"]`)\n  );\n\n/**\n * If the link is the current URL.\n *\n * > Not in the test suite.\n */\nconst sameUrl: PreventCheck = ({ href }) =>\n  url.clean(href) === url.clean() && url.getPort(href) === url.getPort();\n\nexport class Prevent extends Ignore {\n  public suite: string[] = [];\n  public tests: Map<string, PreventCheck> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n    this.init();\n  }\n\n  public init(): void {\n    // Add defaults\n    this.add('pushState', pushState);\n    this.add('exists', exists);\n    this.add('newTab', newTab);\n    this.add('blank', blank);\n    this.add('corsDomain', corsDomain);\n    this.add('corsPort', corsPort);\n    this.add('download', download);\n    this.add('preventSelf', preventSelf);\n    this.add('preventAll', preventAll);\n\n    // Outside of the test suite\n    this.add('sameUrl', sameUrl, false);\n  }\n\n  public add(name: string, check: PreventCheck, suite: boolean = true): void {\n    this.tests.set(name, check);\n    suite && this.suite.push(name);\n  }\n\n  /**\n   * Run individual test\n   */\n  public run(name: string, el: Link, event: Event, href: string): boolean {\n    return this.tests.get(name)({\n      el,\n      event,\n      href,\n    });\n  }\n\n  /**\n   * Run test suite\n   */\n  public checkLink(el: Link, event: Event, href: string): boolean {\n    return this.suite.some(name => this.run(name, el, event, href));\n  }\n}\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class BarbaError extends Error {\n  /* istanbul ignore next */\n  constructor(\n    public error: Error,\n    public label = 'Barba error',\n    ...params: any[]\n  ) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(...params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    /* istanbul ignore else */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BarbaError);\n    }\n\n    this.name = 'BarbaError';\n  }\n}\n","/**\n * @barba/core/modules/store\n * <br><br>\n * ## Transitions store.\n *\n * - Resolve transition\n * - Manage rules\n *\n * @module core/modules/store\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  IRule,\n  IRules,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  RuleName,\n} from '../defs';\n\n// Modules\nimport { Logger } from './Logger';\n\nexport class Store {\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All registered transitions.\n   */\n  public all: ITransitionPage[] = [];\n  /**\n   * \"Page only\" registered transitions.\n   */\n  public page: ITransitionPage[] = [];\n  /**\n   * \"Once only\" registered transitions.\n   */\n  public once: ITransitionOnce[] = [];\n  /**\n   * Rules for transition resolution.\n   *\n   * Defaults:\n   *\n   * - namespace\n   * - custom\n   */\n  private _rules: IRule[] = [\n    {\n      name: 'namespace',\n      type: 'strings',\n    },\n    {\n      name: 'custom',\n      type: 'function',\n    },\n  ];\n\n  /**\n   * Init store.\n   */\n  constructor(transitions: ITransitionPage[] = []) {\n    /* istanbul ignore else */\n    if (transitions) {\n      // TODO: add check for valid transitions? criteria? (once || enter && leave)\n      this.all = this.all.concat(transitions);\n    }\n    this.update();\n  }\n\n  /**\n   * Add rule or transition.\n   */\n  public add(type: 'rule' | 'transition', data: any): void {\n    switch (type) {\n      case 'rule':\n        // TODO: check for valid rule\n        this._rules.splice(data.position || 0, 0, data.value);\n        break;\n      case 'transition':\n      default:\n        // TODO: check for valid transition\n        this.all.push(data);\n        break;\n    }\n\n    this.update();\n  }\n\n  /**\n   * Resolve transition.\n   */\n  public resolve(\n    data: ITransitionData,\n    filters: ITransitionFilters = {}\n  ): ITransitionOnce | ITransitionPage {\n    // Filter on \"once\"\n    let transitions = filters.once ? this.once : this.page;\n\n    // Filter on \"self\"\n    if (filters.self) {\n      transitions = transitions.filter(t => t.name && t.name === 'self');\n    } else {\n      transitions = transitions.filter(t => !t.name || t.name !== 'self');\n    }\n\n    // All matching transition infos\n    const matching = new Map();\n\n    // Active = first of valid transitions\n    // sorted by directions (from/to, from || to, …)\n    const active = transitions.find(t => {\n      let valid = true;\n      const match = {};\n\n      if (filters.self && t.name === 'self') {\n        matching.set(t, match);\n        return true;\n      }\n\n      // Check rules\n      this._rules.reverse().forEach(rule => {\n        if (valid) {\n          valid = this._check(t, rule, data, match);\n          // From/to check\n          if (t.from && t.to) {\n            valid =\n              this._check(t, rule, data, match, 'from') &&\n              this._check(t, rule, data, match, 'to');\n          }\n          if (t.from && !t.to) {\n            valid = this._check(t, rule, data, match, 'from');\n          }\n          if (!t.from && t.to) {\n            valid = this._check(t, rule, data, match, 'to');\n          }\n        }\n      });\n\n      matching.set(t, match);\n\n      return valid;\n    });\n\n    const activeMatch = matching.get(active);\n    const transitionType = [];\n    if (filters.once) {\n      transitionType.push('once');\n    } else {\n      transitionType.push('page');\n    }\n    if (filters.self) {\n      transitionType.push('self');\n    }\n\n    if (activeMatch) {\n      // Log resolved transition\n      const infos: any[] = [active];\n      // Log if matching criteria\n      Object.keys(activeMatch).length > 0 && infos.push(activeMatch);\n\n      this.logger.info(\n        `Transition found [${transitionType.join(',')}]`,\n        ...infos\n      );\n    } else {\n      this.logger.info(`No transition found [${transitionType.join(',')}]`);\n    }\n\n    return active;\n  }\n\n  /**\n   * ### Update store.\n   *\n   * - Reorder transition by priorities\n   * - Get wait indicator\n   * - Get once transitions\n   */\n  public update(): void {\n    // Reorder by priorities\n    this.all = this.all\n      .map(t => this._addPriority(t))\n      .sort((a, b) => a.priority - b.priority)\n      .reverse()\n      .map(t => {\n        delete t.priority;\n\n        return t;\n      });\n    this.page = this.all.filter(\n      t => t.leave !== undefined || t.enter !== undefined\n    ) as ITransitionPage[];\n    this.once = this.all.filter(t => t.once !== undefined) as ITransitionOnce[];\n  }\n\n  /**\n   * ### Check if transition apply.\n   *\n   * Based on rule, page data and optional direction:\n   *\n   * 1. transition has no rule \"property\":\n   *    - always returns true\n   * 2. transition has rule \"property\":\n   *     - \"strings\" should be present on both side (transition + page) and match\n   *     - \"function\" should return true\n   */\n  private _check(\n    transition: ITransitionPage,\n    rule: IRule,\n    data: ITransitionData,\n    match: any,\n    direction?: 'from' | 'to'\n  ): boolean {\n    let isValid = true;\n    let hasMatch = false;\n    const t = transition;\n    const { name, type } = rule;\n    const strRule = name as IRules['strings'];\n    const objRule = name as IRules['object'];\n    const fnName = name as IRules['function'];\n    const base = direction ? t[direction] : t; // = t || t.from || t.to\n    const page = direction === 'to' ? data.next : data.current; // = current || next\n    const exist = direction ? base && base[name] : base[name];\n\n    // If transition rule exists\n    if (exist) {\n      switch (type) {\n        case 'strings':\n        default: {\n          // Array support\n          const names: string[] = Array.isArray(base[strRule])\n            ? (base[strRule] as string[])\n            : [base[strRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[strRule] && names.indexOf(page[strRule]) !== -1) {\n            hasMatch = true;\n          }\n          // If transition prop is different from current, not valid\n          if (names.indexOf(page[strRule]) === -1) {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'object': {\n          // Array support\n          const names: string[] = Array.isArray(base[objRule])\n            ? (base[objRule] as string[])\n            : [base[objRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[objRule]) {\n            if (\n              page[objRule].name &&\n              names.indexOf(page[objRule].name) !== -1\n            ) {\n              hasMatch = true;\n            }\n            // If transition prop is different from current, not valid\n            if (names.indexOf(page[objRule].name) === -1) {\n              isValid = false;\n            }\n          } else {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'function':\n          if (base[fnName](data)) {\n            hasMatch = true;\n          } else {\n            isValid = false;\n          }\n          break;\n      }\n\n      if (hasMatch) {\n        if (direction) {\n          match[direction] = match[direction] || {};\n          match[direction][name] = t[direction][name];\n        } else {\n          match[name] = t[name];\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  /**\n   * ### Calculate transition priority.\n   *\n   * Based on:\n   *\n   * - rule \"position\" (index) give tens, hundreds, thousands, …\n   * - from/to properties give units (0, 1 or 2)\n   */\n  private _calculatePriority(\n    t: ITransitionPage,\n    ruleName: RuleName,\n    ruleIndex: number\n  ): number {\n    let priority = 0;\n\n    if (\n      t[ruleName] ||\n      (t.from && t.from[ruleName]) ||\n      (t.to && t.to[ruleName])\n    ) {\n      priority += Math.pow(10, ruleIndex);\n\n      if (t.from && t.from[ruleName]) {\n        priority += 1;\n      }\n      if (t.to && t.to[ruleName]) {\n        priority += 2;\n      }\n    }\n\n    return priority;\n  }\n\n  private _addPriority(t: ITransitionPage): ITransitionPage {\n    t.priority = 0;\n    let priority = 0;\n\n    this._rules.forEach((rule, i) => {\n      const { name } = rule;\n      const index = i + 1;\n\n      priority += this._calculatePriority(t, name, index);\n    });\n\n    t.priority = priority;\n\n    return t;\n  }\n}\n","/**\n * @barba/core/modules/transitions\n * <br><br>\n * ## Transitions manager.\n *\n * - Handle hooks and transition lifecycle\n *\n * @module core/modules/transitions\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  HooksTransition,\n  HooksTransitionMap,\n  IResponse,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionOnce,\n  ITransitionPage,\n  Wrapper,\n} from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { dom, helpers, runAsync } from '../utils';\n// Modules\nimport { BarbaError } from './Error';\nimport { Logger } from './Logger';\nimport { Store } from './Store';\n\nexport class Transitions {\n  public logger: Logger = new Logger('@barba/core');\n  public store: Store;\n  private _running: boolean = false;\n\n  constructor(transitions: ITransitionPage[] = []) {\n    this.store = new Store(transitions);\n  }\n\n  /**\n   * Get resolved transition\n   *\n   * - based on data\n   */\n  public get(\n    data: ITransitionData,\n    filters?: ITransitionFilters\n  ): ITransitionOnce | ITransitionPage {\n    return this.store.resolve(data, filters);\n  }\n\n  /**\n   * Animation running status.\n   */\n  get isRunning(): boolean {\n    return this._running;\n  }\n  set isRunning(status: boolean) {\n    this._running = status;\n  }\n\n  /**\n   * Check for registered once transition(s).\n   */\n  get hasOnce(): boolean {\n    return this.store.once.length > 0;\n  }\n\n  /**\n   * Check for registered self transition.\n   */\n  get hasSelf(): boolean {\n    return this.store.all.some(t => t.name === 'self');\n  }\n\n  /**\n   * ### Wait indicator.\n   *\n   * Tells Barba to get next page data<br>\n   * before starting the resolution<br>\n   * because some registered transitions need<br>\n   * next page data to be resolved (eg: `sync: true`, `to: { namespace }`, …)\n   */\n  get shouldWait(): boolean {\n    return this.store.all.some(t => (t.to && !t.to.route) || t.sync);\n  }\n\n  /**\n   * ### Do \"once\" transition.\n   *\n   * Hooks: see [[HooksOnce]].\n   */\n  public async doOnce({\n    data,\n    transition,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionOnce;\n  }) {\n    const t = transition || {};\n    this._running = true;\n\n    try {\n      await this._doAsyncHook('beforeOnce', data, t);\n      await this.once(data, t);\n      await this._doAsyncHook('afterOnce', data, t);\n    } catch (error) {\n      this._running = false;\n\n      this.logger.debug('Transition error [before/after/once]');\n      this.logger.error(error);\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * ### Do \"page\" transition.\n   *\n   * Hooks: see [[HooksPage]].\n   *\n   * `sync: false` (default) order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. leave\n   * 4. afterLeave\n   * 5. beforeEnter\n   * 6. enter\n   * 7. afterEnter\n   * 8. after\n   *\n   * `sync: true` order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. beforeEnter\n   * 4. leave & enter\n   * 5. afterLeave\n   * 6. afterEnter\n   * 7. after\n   */\n  public async doPage({\n    data,\n    transition,\n    page,\n    wrapper,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionPage;\n    page: Promise<IResponse | void>;\n    wrapper: Wrapper;\n  }) {\n    const t = transition || {};\n    const sync = t.sync === true || false;\n\n    this._running = true;\n\n    try {\n      // Check sync mode, wait for next content\n      if (sync) {\n        await helpers.update(page, data);\n      }\n\n      await this._doAsyncHook('before', data, t);\n\n      if (sync) {\n        try {\n          await this.add(data, wrapper);\n          // Before actions\n          await this._doAsyncHook('beforeLeave', data, t);\n          await this._doAsyncHook('beforeEnter', data, t);\n\n          // Actions\n          await Promise.all([this.leave(data, t), this.enter(data, t)]);\n\n          // After actions\n          await this._doAsyncHook('afterLeave', data, t);\n          await this._doAsyncHook('afterEnter', data, t);\n        } catch (error) {\n          // this.logger.debug('Transition error [sync]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              (error as Error),\n              'Transition error [sync]'\n            );\n          }\n        }\n      } else {\n        let leaveResult: any = false;\n\n        try {\n          // Leave\n          await this._doAsyncHook('beforeLeave', data, t);\n\n          leaveResult = await Promise.all([\n            this.leave(data, t),\n            helpers.update(page, data),\n          ]).then(values => values[0]);\n\n          await this._doAsyncHook('afterLeave', data, t);\n\n          // TODO: check here \"valid\" page result\n          // before going further\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/leave]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              (error as Error),\n              'Transition error [before/after/leave]'\n            );\n          }\n        }\n\n        try {\n          // Enter\n          /* istanbul ignore else */\n          if (leaveResult !== false) {\n            await this.add(data, wrapper);\n\n            await this._doAsyncHook('beforeEnter', data, t);\n            await this.enter(data, t, leaveResult);\n            await this._doAsyncHook('afterEnter', data, t);\n          }\n        } catch (error) {\n          // this.logger.debug('Transition error [before/after/enter]');\n          // this.logger.error(error);\n          if (this._isTransitionError(error)) {\n            throw new BarbaError(\n              (error as Error),\n              'Transition error [before/after/enter]'\n            );\n          }\n        }\n      }\n\n      // Remove current container\n      await this.remove(data);\n\n      await this._doAsyncHook('after', data, t);\n    } catch (error: any) {\n      this._running = false;\n\n      // If \"custom/specific\" barba error.\n      /* istanbul ignore else */\n      if (error.name && error.name === 'BarbaError') {\n        this.logger.debug(error.label);\n        this.logger.error(error.error);\n\n        throw error;\n      }\n\n      this.logger.debug('Transition error [page]');\n      this.logger.error(error);\n\n      throw error;\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * Once hook + async \"once\" transition.\n   */\n  public async once(data: ITransitionData, t: ITransitionOnce): Promise<void> {\n    await hooks.do('once', data, t);\n\n    return t.once ? runAsync(t.once, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Leave hook + async \"leave\" transition.\n   */\n  public async leave(data: ITransitionData, t: ITransitionPage): Promise<any> {\n    await hooks.do('leave', data, t);\n\n    return t.leave ? runAsync(t.leave, t)(data) : Promise.resolve();\n  }\n\n  /**\n   * Enter hook + async \"enter\" transition.\n   */\n  public async enter(\n    data: ITransitionData,\n    t: ITransitionPage,\n    leaveResult?: any\n  ): Promise<void> {\n    await hooks.do('enter', data, t);\n\n    return t.enter\n      ? runAsync(t.enter, t)(data, leaveResult)\n      : Promise.resolve();\n  }\n\n  /**\n   * Add next container.\n   */\n  public async add(data: ITransitionData, wrapper: Wrapper): Promise<void> {\n    dom.addContainer(data.next.container, wrapper);\n    hooks.do('nextAdded', data);\n  }\n\n  /**\n   * Remove current container.\n   */\n  public async remove(data: ITransitionData): Promise<void> {\n    dom.removeContainer(data.current.container);\n    hooks.do('currentRemoved', data);\n  }\n\n  private _isTransitionError(error: any) {\n    if (error.message) {\n      // Errors from request\n      return !/Timeout error|Fetch error/.test(error.message);\n    }\n\n    if (error.status) {\n      // Errors from request\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Do hooks + async transition methods.\n   */\n  private async _doAsyncHook(\n    hook: HooksTransition,\n    data: ITransitionData,\n    t: HooksTransitionMap\n  ): Promise<void> {\n    await hooks.do(hook, data, t);\n\n    return t[hook] ? runAsync(t[hook], t)(data) : Promise.resolve();\n  }\n}\n","/**\n * @barba/core/modules/views\n * <br><br>\n * ## Views manager.\n *\n * @module core/modules/views\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HooksView, IView, IViewData } from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { runAsync } from '../utils';\n// Types\ntype Hook = (data: IViewData) => Promise<void>;\n\nexport class Views {\n  /**\n   * Available hook names for views.\n   */\n  public names: HooksView[] = [\n    'beforeLeave',\n    'afterLeave',\n    'beforeEnter',\n    'afterEnter',\n  ];\n  /**\n   * Registered views by namespace.\n   */\n  public byNamespace: Map<string, IView> = new Map();\n\n  /**\n   * Init views.\n   */\n  constructor(views: IView[]) {\n    if (views.length === 0) {\n      return;\n    }\n\n    // TODO: add check\n    // for valid views? criteria? (namespace property, string ?)\n    // or duplicate\n    views.forEach(view => {\n      this.byNamespace.set(view.namespace, view);\n    });\n\n    this.names.forEach(name => {\n      hooks[name](this._createHook(name));\n    });\n  }\n\n  /**\n   * Create the hook method.\n   *\n   * - get view based on namespace\n   * - execute callback with transition data\n   */\n  private _createHook(name: HooksView): Hook {\n    return data => {\n      const { namespace } = name.match(/enter/i) ? data.next : data.current;\n      const view = this.byNamespace.get(namespace);\n\n      // TODO: manage self…\n      // if (view && data.trigger !== 'self') {\n      if (view && view[name]) {\n        return runAsync(view[name], view)(data);\n      }\n\n      return Promise.resolve();\n    };\n  }\n}\n","// Element.prototype.matches polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    (Element as any).prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n}\n\n// Element.prototype.closest polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function closest(s: string) {\n    let el = this;\n\n    do {\n      if (el.matches(s)) {\n        return el;\n      }\n\n      el = (el.parentElement || el.parentNode) as Element;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n","/**\n * @module core/schemas\n */\n\n// Definitions\nimport { ISchemaPage } from '../defs';\n\n/**\n * See [[ISchemaPage]]\n */\nexport const schemaPage: ISchemaPage = {\n  container: null,\n  html: '',\n  namespace: '',\n  url: {\n    hash: '',\n    href: '',\n    path: '',\n    port: null,\n    query: {},\n  },\n};\n","/**\n * @barba/core\n * <br><br>\n * ## Barba core object\n *\n * Main methods:\n *\n * - `.init()` for initialization with options\n * - `.use()` for plugins\n *\n * @module core\n */\n\n/***/\n\nimport { version } from '../package.json';\n// Definitions\nimport {\n  IBarbaOptions,\n  IBarbaPlugin,\n  IgnoreOption,\n  ISchemaPage,\n  ITransitionData,\n  ITransitionOnce,\n  ITransitionPage,\n  Link,\n  LinkEvent,\n  RequestCustomError,\n  RequestErrorOrResponse,\n  SchemaAttributeValues,\n  Trigger,\n  Wrapper,\n} from './defs';\n// Hooks\nimport { hooks } from './hooks';\n// Modules\nimport { Cache } from './modules/Cache';\nimport { Headers } from './modules/Headers';\nimport { Logger } from './modules/Logger';\nimport { Prevent } from './modules/Prevent';\nimport { Transitions } from './modules/Transitions';\nimport { Views } from './modules/Views';\n// Polyfills\nimport './polyfills';\n// Schemas\nimport { schemaAttribute } from './schemas/attribute';\nimport { schemaPage } from './schemas/page';\n// Utils\nimport { dom, helpers, history, request, url } from './utils';\n\nexport class Core {\n  /**\n   * Version.\n   */\n  public version: string = version;\n  /**\n   * Schemas.\n   */\n  public schemaPage: ISchemaPage = schemaPage;\n  /**\n   * Logger class, allows plugins to create Logger.\n   */\n  public Logger: typeof Logger = Logger;\n  /**\n   * Barba logger.\n   */\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * Plugins.\n   */\n  public plugins: IBarbaPlugin<any>[] = [];\n  /**\n   * Options\n   */\n  public timeout: number;\n  public cacheIgnore: IgnoreOption;\n  public cacheFirstPage: boolean;\n  public prefetchIgnore: IgnoreOption;\n  public preventRunning: boolean;\n  /**\n   * Hooks\n   */\n  public hooks = hooks;\n  /**\n   * Modules.\n   */\n  // public history: History;\n  public cache: Cache;\n  public headers: Headers;\n  public prevent: Prevent;\n  public transitions: Transitions;\n  public views: Views;\n  /**\n   * Utils.\n   */\n  public dom = dom;\n  public helpers = helpers;\n  public history = history;\n  public request = request;\n  public url = url;\n\n  private _data: ITransitionData;\n  private _requestCustomError: RequestCustomError;\n  private _wrapper: Wrapper;\n  private _linkEvent: LinkEvent;\n\n  /**\n   * ### Init plugin with options.\n   *\n   * See [[IBarbaPlugin]] for more details.\n   */\n  public use<T>(plugin: IBarbaPlugin<T>, options?: T): void {\n    const installedPlugins = this.plugins;\n\n    // Plugin installation\n    if (installedPlugins.indexOf(plugin) > -1) {\n      this.logger.warn(`Plugin [${plugin.name}] already installed.`);\n\n      return;\n    }\n\n    if (typeof plugin.install !== 'function') {\n      this.logger.warn(`Plugin [${plugin.name}] has no \"install\" method.`);\n\n      return;\n    }\n\n    plugin.install(this, options);\n    installedPlugins.push(plugin);\n  }\n\n  /**\n   * ### Init barba with options.\n   *\n   * See [[IBarbaOptions]] for more details.\n   *\n   * Default values are:\n   *\n   * - transitions: `[]`\n   * - views: `[]`\n   * - schema: [[SchemaAttribute]]\n   * - timeout: `2e3`\n   * - cacheIgnore: `false`\n   * - cacheFirstPage: `false`\n   * - prefetchIgnore: `false`\n   * - preventRunning: `false`\n   * - prevent: `null`,\n   * - debug: `false`\n   * - logLevel: `'debug'`\n   */\n  public init(\n    /** @ignore */ {\n      transitions = [],\n      views = [],\n      schema = schemaAttribute,\n      requestError,\n      timeout = 2e3,\n      cacheIgnore = false,\n      cacheFirstPage = false,\n      prefetchIgnore = false,\n      /* istanbul ignore next */\n      preventRunning = false,\n      prevent: preventCustom = null,\n      debug = false,\n      logLevel = 'off',\n    }: IBarbaOptions = {}\n  ) {\n    // 0. Set logger level and print version\n    Logger.setLevel(debug === true ? 'debug' : logLevel);\n    this.logger.info(this.version);\n\n    // 1. Manage options\n    Object.keys(schema).forEach(k => {\n      const attr = k as SchemaAttributeValues;\n\n      /* istanbul ignore else */\n      if (schemaAttribute[attr]) {\n        schemaAttribute[attr] = schema[attr];\n      }\n    });\n    this._requestCustomError = requestError;\n    this.timeout = timeout;\n    this.cacheIgnore = cacheIgnore;\n    this.cacheFirstPage = cacheFirstPage;\n    this.prefetchIgnore = prefetchIgnore;\n    this.preventRunning = preventRunning;\n\n    // 2. Get and check wrapper\n    this._wrapper = this.dom.getWrapper();\n    if (!this._wrapper) {\n      throw new Error('[@barba/core] No Barba wrapper found');\n    }\n\n    // 3. Init pages (get \"current\" data)\n    this._resetData();\n\n    const { current } = this.data;\n\n    if (!current.container) {\n      throw new Error('[@barba/core] No Barba container found');\n    }\n\n    // 4. Init other modules\n    this.cache = new Cache(cacheIgnore);\n    this.headers = new Headers();\n    this.prevent = new Prevent(prefetchIgnore);\n    this.transitions = new Transitions(transitions);\n    this.views = new Views(views);\n\n    // Add prevent custom\n    if (preventCustom !== null) {\n      if (typeof preventCustom !== 'function') {\n        throw new Error('[@barba/core] Prevent should be a function');\n      }\n\n      this.prevent.add('preventCustom', preventCustom);\n    }\n\n    // 5. Init history\n    this.history.init(current.url.href, current.namespace);\n\n    // 6. Add to cache\n    if (cacheFirstPage) {\n      this.cache.set(current.url.href, Promise.resolve({\n        html: current.html,\n        url: current.url,\n      }), 'init', 'fulfilled');\n    }\n\n    // 7. Bind context\n    this._onLinkEnter = this._onLinkEnter.bind(this);\n    this._onLinkClick = this._onLinkClick.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._bind();\n\n    // 8. Init plugins\n    this.plugins.forEach(plugin => plugin.init());\n\n    // 9. Barba ready\n    // Set next + trigger for once and `beforeEnter`/`afterEnter` view on page load.\n    const onceData = this.data;\n\n    onceData.trigger = 'barba';\n    onceData.next = onceData.current;\n    onceData.current = { ...this.schemaPage };\n    this.hooks.do('ready', onceData);\n\n    // 9. Finally, do once…\n    this.once(onceData);\n\n    // Clean data for first barba transition…\n    this._resetData();\n  }\n\n  public destroy(): void {\n    this._resetData();\n    this._unbind();\n    this.history.clear();\n    this.hooks.clear();\n    this.plugins = [];\n  }\n\n  get data(): ITransitionData {\n    return this._data;\n  }\n\n  get wrapper(): HTMLElement {\n    return this._wrapper;\n  }\n\n  /**\n   * ### Force a page change without Barba transition.\n   */\n  public force(href: string): void {\n    // DEV\n    // Can be used waiting animation cancellation management…\n    window.location.assign(href);\n  }\n\n  /**\n   * ### Go for a Barba transition.\n   *\n   * Manage \"self page\" href:\n   *\n   * - if same url and no self transition, keep default behavior\n   *   - link: reload the page\n   *   - anchor: scroll to\n   * - if same url with self transition, use it\n   * - then start a page transition.\n   */\n  public go(\n    href: string,\n    trigger: Trigger = 'barba',\n    e?: LinkEvent | PopStateEvent\n  ): Promise<void> {\n    this._linkEvent = null;\n\n    // If animation running, force reload\n    if (this.transitions.isRunning) {\n      this.force(href);\n\n      return;\n    }\n\n    let self = false;\n\n    // Check prevent sameURL against current history\n    // + state check\n    // + update trigger with direction\n    if (trigger === 'popstate') {\n      self =\n        this.history.current &&\n        this.url.getPath(this.history.current.url) === this.url.getPath(href) &&\n        this.url.getQuery(this.history.current.url, true) === this.url.getQuery(href, true);\n    } else {\n      self = this.prevent.run('sameUrl', null, null, href);\n    }\n\n    if (self && !this.transitions.hasSelf) {\n      return;\n    }\n\n    trigger = this.history.change(this.cache.has(href) ? this.cache.get(href).target : href, trigger, e);\n\n    if (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    return this.page(href, trigger, e ?? undefined, self);\n  }\n\n  /**\n   * ### Start an \"once\" transition.\n   *\n   * If some registered \"once\" transition,\n   * get the \"resolved\" transition from the store and start it.\n   */\n  public async once(readyData: ITransitionData): Promise<void> {\n    await this.hooks.do('beforeEnter', readyData);\n\n    // Check if once transition\n    if (this.transitions.hasOnce) {\n      const transition = this.transitions.get(readyData, {\n        once: true,\n      }) as ITransitionOnce;\n\n      await this.transitions.doOnce({ transition, data: readyData });\n    }\n\n    await this.hooks.do('afterEnter', readyData);\n  }\n\n  /**\n   * ### Start a \"page\" transition.\n   *\n   * 1. If no running transition, updates data with full URL properties and trigger.\n   * 2. Get page from cache or init request.\n   * 3. Wait if some transitions need \"next\" data (`sync: true`, `to: …`).\n   * 4. Manage the history, depending on trigger.\n   * 5. Get \"data\" and trigger \"go\" hook.\n   * 6. Get the \"resolved\" transition from the store and start it.\n   * 7. Update title and reset data (current, next = undefined).\n   *\n   * > If \"self\", use the \"self\" transition\n   */\n  public async page(\n    href: string,\n    trigger: Trigger,\n    event: LinkEvent | PopStateEvent,\n    self: boolean\n  ): Promise<void> {\n    this.data.next.url = {\n      href,\n      ...this.url.parse(href),\n    };\n    this.data.trigger = trigger;\n    this.data.event = event;\n\n    let page;\n\n    if (this.cache.has(href)) {\n      page = this.cache.update(href, { action: 'click' }).request;\n    } else {\n      const pageRequest = this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, trigger),\n        this.cache,\n        this.headers\n      );\n\n      // manage 301 server response: replace history\n      pageRequest.then(response => {\n        /* istanbul ignore next: bypass jest since xhr-mock doesn't support custom xhr.responseURL */\n        if (response.url.href !== href) {\n          this.history.add(response.url.href, trigger, 'replace');\n        }\n      });\n\n      page = this.cache.set(href, pageRequest, 'click', 'pending').request;\n    }\n\n    // Need to wait before getting the right transition\n    if (this.transitions.shouldWait) {\n      await helpers.update(page, this.data);\n    }\n\n    const data = this.data;\n\n    // Hook: between trigger and transition\n    // Can be used to resolve \"route\"…\n    await this.hooks.do('page', data);\n\n    try {\n      const transition = this.transitions.get(data, {\n        once: false,\n        self,\n      }) as ITransitionPage;\n\n      await this.transitions.doPage({\n        data,\n        page,\n        transition,\n        wrapper: this._wrapper,\n      });\n\n      this._resetData();\n    } catch (error) {\n      // Something went wrong (rejected promise, error, 404, 505, other…)\n      // TODO: manage / use cases for cancellation\n      // this.logger.debug('Transition cancelled');\n\n      // If transition error and no debug mode, force reload page.\n      /* istanbul ignore else */\n      if (Logger.getLevel() === 0) {\n        this.force(data.next.url.href);\n      }\n    }\n  }\n\n  /**\n   * When a request error occurs.\n   *\n   * Allow the user to manage request error. (E.g: 404)\n   */\n  public onRequestError(trigger: Trigger, ...args: any): boolean {\n    // Cancel transition status\n    this.transitions.isRunning = false;\n\n    const [href, response]: [string, RequestErrorOrResponse] = args;\n    const action = this.cache.getAction(href);\n    this.cache.delete(href);\n\n    // Custom requestError returning false will return here.\n    if (\n      this._requestCustomError &&\n      this._requestCustomError(trigger, action, href, response) === false\n    ) {\n      return false;\n    }\n\n    // Force page change\n    if (action === 'click') {\n      this.force(href);\n    }\n    return false;\n  }\n\n  /**\n   * Programmatically prefetch\n   */\n  public prefetch(href: string) {\n\n    // only prefetch absolute href\n    href = this.url.getAbsoluteHref(href);\n\n    // Already in cache\n    /* istanbul ignore next */\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, 'barba'),\n        this.cache,\n        this.headers\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'prefetch',\n      'pending'\n    );\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _bind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.addEventListener('mouseover', this._onLinkEnter);\n      document.addEventListener('touchstart', this._onLinkEnter);\n    }\n    document.addEventListener('click', this._onLinkClick);\n    window.addEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _unbind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.removeEventListener('mouseover', this._onLinkEnter);\n      document.removeEventListener('touchstart', this._onLinkEnter);\n    }\n    document.removeEventListener('click', this._onLinkClick);\n    window.removeEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * When a element is entered.\n   *\n   * Get valid link element.\n   * Cache URL if needed.\n   */\n  private _onLinkEnter(e: LinkEvent): void {\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    const href = this.url.getAbsoluteHref(this.dom.getHref(link));\n\n    if (this.prevent.checkHref(href)) {\n      return;\n    }\n\n    // Already in cache\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, link),\n        this.cache,\n        this.headers\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'enter',\n      'pending'\n    );\n  }\n\n  /**\n   * When an element is clicked.\n   *\n   * Get valid link element.\n   * Prevent same URL.\n   * Go for a Barba transition.\n   */\n  private _onLinkClick(e: LinkEvent): void {\n\n    // This use `prevent.checkLink` under the hood to get eligible link.\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    if (this.transitions.isRunning && this.preventRunning) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      return;\n    }\n\n    this._linkEvent = e;\n\n    this.go(this.dom.getHref(link), link, e);\n  }\n\n  /**\n   * When History state changes.\n   *\n   * Get \"href\" from URL\n   * Go for a Barba transition.\n   */\n  private _onStateChange(e: PopStateEvent): void {\n    this.go(this.url.getHref(), 'popstate', e);\n  }\n\n  /**\n   * Get a valid link ancestor.\n   *\n   * Check for a \"href\" attribute.\n   * Then check if eligible for Barba.\n   */\n  private _getLinkElement(e: LinkEvent): Link {\n    let el = e.target as Link;\n\n    while (el && !this.dom.getHref(el)) {\n      el = (el as HTMLElement).parentNode as Link;\n    }\n\n    // Check prevent\n    if (!el || this.prevent.checkLink(el, e, this.dom.getHref(el))) {\n      return;\n    }\n\n    return el;\n  }\n\n  /**\n   * Reset pages data.\n   *\n   * Set \"current\" and unset \"next\".\n   */\n  private _resetData() {\n    const href = this.url.getHref();\n    const current = {\n      container: this.dom.getContainer(),\n      html: this.dom.getHtml(),\n      namespace: this.dom.getNamespace(),\n      url: {\n        href,\n        ...this.url.parse(href),\n      },\n    };\n\n    this._data = {\n      current,\n      event: undefined,\n      next: { ...this.schemaPage },\n      trigger: undefined,\n    };\n\n    this.hooks.do('reset', this.data);\n  }\n}\n\nconst core = new Core();\n\nexport default core;\n"],"names":["LogLevels","HookMethods","constructor","this","before","beforeLeave","leave","afterLeave","beforeEnter","enter","afterEnter","after","_level","off","Logger","static","name","source","_source","error","objects","_log","console","warn","warning","info","debug","log","fn","level","getLevel","apply","concat","escapeString","str","replace","flags","options","sensitive","schemaAttribute","container","history","namespace","prefix","prevent","wrapper","Dom","_attr","_parser","_sibling","parent","toString","el","outerHTML","toDocument","htmlString","DOMParser","parseFromString","toElement","div","document","createElement","innerHTML","getHtml","doc","documentElement","getWrapper","scope","querySelector","getContainer","removeContainer","body","contains","_updateSibling","parentNode","removeChild","addContainer","siblingBefore","_insertAfter","insertBefore","appendChild","getSibling","getNamespace","ns","getAttribute","getHref","tagName","toLowerCase","href","resolveUrl","baseVal","urls","numUrls","length","base","arguments","head","getElementsByTagName","firstChild","a","resolved","index","newNode","referenceNode","nextSibling","nextElementSibling","previousElementSibling","parentElement","_session","_states","_pointer","init","url","data","scroll","x","window","scrollX","y","scrollY","push","state","item","from","states","replaceState","change","trigger","e","_getDirection","add","action","method","_getAction","size","set","pushState","store","i","get","update","existing","remove","splice","pop","clear","newStates","current","attr","hasAttribute","diff","Math","abs","async","page","next","html","response","nextDocument","dom","title","pathToRegexp","path","keys","RegExp","groupsRegex","execResult","exec","suffix","modifier","pattern","regexpToRegexp","Array","isArray","paths","parts","map","join","arrayToRegexp","tokens","_a","strict","_b","start","_c","end","_d","encode","_e","delimiter","_f","endsWith","endsWithRe","delimiterRe","route","_i","tokens_1","token","mod","endToken","isEndDelimited","indexOf","undefined","tokensToRegexp","char","type","value","count","j","TypeError","code","charCodeAt","lexer","prefixes","defaultPattern","result","key","tryConsume","mustConsume","consumeText","name_1","pattern_1","parse","stringToRegexp","Promise","resolve","requestAnimationFrame","getOrigin","location","origin","getPort","port","matches","match","test","portString","substring","parseInt","hashIndex","hash","slice","queryIndex","query","parseQuery","split","reduce","acc","clean","baseURI","URL","stringify","JSON","ttl","requestError","cache","headers","reject","xhr","XMLHttpRequest","onreadystatechange","readyState","DONE","status","responseURL","responseText","target","statusText","ontimeout","onerror","Error","open","timeout","setRequestHeader","all","forEach","send","runAsync","func","ctx","args","err","answer","obj","then","promise","hooks","super","logger","registered","Map","hook","has","Set","do","chain","catch","help","_value","Ignore","ignore","_ignoreAll","_ignoreRegexes","p","checkHref","some","regex","Cache","_state","request","getRequest","getAction","getStatus","getTarget","delete","_extends","_list","exists","newTab","event","which","metaKey","ctrlKey","shiftKey","altKey","blank","corsDomain","protocol","hostname","corsPort","download","preventSelf","preventAll","Boolean","closest","sameUrl","Prevent","suite","tests","check","run","checkLink","BarbaError","label","params","captureStackTrace","Store","transitions","once","_rules","position","filters","filter","self","t","matching","active","find","valid","reverse","rule","_check","to","activeMatch","transitionType","infos","Object","_addPriority","sort","b","priority","transition","direction","isValid","hasMatch","strRule","objRule","fnName","names","_calculatePriority","ruleName","ruleIndex","pow","Transitions","_running","isRunning","hasOnce","hasSelf","shouldWait","sync","_doAsyncHook","helpers.update","_isTransitionError","leaveResult","helpers","values","message","Views","views","byNamespace","view","_createHook","Element","prototype","msMatchesSelector","webkitMatchesSelector","s","nodeType","schemaPage","core","Core","version","plugins","cacheIgnore","cacheFirstPage","prefetchIgnore","preventRunning","_data","_requestCustomError","_wrapper","_linkEvent","use","plugin","installedPlugins","install","schema","preventCustom","logLevel","setLevel","k","_resetData","Headers","_onLinkEnter","bind","_onLinkClick","_onStateChange","_bind","onceData","destroy","_unbind","force","assign","go","getPath","getQuery","stopPropagation","preventDefault","readyData","doOnce","pageRequest","onRequestError","doPage","prefetch","getAbsoluteHref","addEventListener","removeEventListener","link","_getLinkElement"],"mappings":"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"}